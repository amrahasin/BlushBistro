package com.example.blushbistroapp.ui.screens

import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.tween
import androidx.compose.animation.fadeIn
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Logout
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.blushbistroapp.R
import com.example.blushbistroapp.data.FirestoreService
import com.example.blushbistroapp.data.Recipe
import com.example.blushbistroapp.data.RecipeCategory
import com.example.blushbistroapp.data.FirebaseAuthService
import com.example.blushbistroapp.ui.components.ThemeToggle
import com.example.blushbistroapp.ui.components.UserProfileDialog
import com.example.blushbistroapp.ui.components.AddRecipeDialog
import com.example.blushbistroapp.ui.components.RecipeCard
import com.example.blushbistroapp.ui.screens.SettingsScreen
import kotlinx.coroutines.launch
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope

enum class DashboardTab {
    HOME, FAVORITES, PROFILE, SETTINGS
}

data class Ingredient(
    val name: String,
    val quantity: String,
    val unit: String
)

private object DashboardScreenConstants {
    const val TAG = "DashboardScreen"
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(
    onSignOut: () -> Unit,
    onNavigateToProfile: () -> Unit,
    onNavigateToSettings: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val firestoreService = remember { FirestoreService.getInstance(context) }
    val authService = remember { FirebaseAuthService.getInstance(context) }
    
    var recipes by remember { mutableStateOf<List<Recipe>>(emptyList()) }
    var userFavorites by remember { mutableStateOf<List<String>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    var error by remember { mutableStateOf<String?>(null) }
    
    val currentUser = authService.getCurrentUser()
    
    var showProfileDialog by remember { mutableStateOf(false) }
    var visible by remember { mutableStateOf(false) }
    var searchQuery by remember { mutableStateOf("") }
    var selectedCategories by remember { mutableStateOf(setOf(RecipeCategory.ALL)) }
    var showAddRecipeDialog by remember { mutableStateOf(false) }
    var selectedTab by remember { mutableStateOf(DashboardTab.HOME) }
    var showRecipeDetails by remember { mutableStateOf<Recipe?>(null) }
    
    // Function to update favorites
    fun updateFavorites(recipeId: String, isFavorite: Boolean) {
        scope.launch {
            currentUser?.uid?.let { userId ->
                val updatedFavorites = if (isFavorite) {
                    userFavorites + recipeId
                } else {
                    userFavorites - recipeId
                }
                
                // Save to Firestore
                firestoreService.saveUserFavorites(userId, updatedFavorites).onSuccess {
                    // Update local state
                    userFavorites = updatedFavorites
                    
                    // Show success message
                    error = if (isFavorite) "Recipe added to favorites" else "Recipe removed from favorites"
                    
                    // Clear the message after 2 seconds
                    kotlinx.coroutines.delay(2000)
                    error = null
                }.onFailure { exception ->
                    error = exception.message ?: "Failed to update favorites"
                }
            }
        }
    }
    
    // Function to load recipes
    fun loadRecipes() {
        scope.launch {
            isLoading = true
            error = null
            try {
                // Check if user is authenticated
                if (currentUser == null) {
                    error = "You must be logged in to view recipes"
                    isLoading = false
                    return@launch
                }
                
                // Load recipes and favorites in parallel
                val recipesDeferred = coroutineScope {
                    async {
                        firestoreService.getRecipesForCurrentUser()
                    }
                }
                
                val favoritesDeferred = coroutineScope {
                    async {
                        firestoreService.getUserFavorites(currentUser.uid).collect { result ->
                            result.onSuccess { favorites ->
                                userFavorites = favorites
                            }.onFailure { exception ->
                                error = exception.message ?: "Failed to load favorites"
                            }
                        }
                    }
                }
                
                // Wait for both operations to complete
                recipes = recipesDeferred.await()
                
                // Initialize predefined recipes only if needed (first time)
                if (recipes.isEmpty()) {
                    firestoreService.initializePredefinedRecipes()
                    // Reload recipes after initialization
                    recipes = firestoreService.getRecipesForCurrentUser()
                }
                
            } catch (e: Exception) {
                error = "Failed to load recipes: ${e.message}"
            } finally {
                isLoading = false
            }
        }
    }

    // Load recipes when the screen is first displayed
    LaunchedEffect(Unit) {
        visible = true
        loadRecipes()
    }
    
    // Only reload recipes when the user changes, not on every recomposition
    LaunchedEffect(currentUser?.uid) {
        if (currentUser != null) {
            loadRecipes()
        }
    }
    
    // Show loading indicator
    if (isLoading) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            CircularProgressIndicator(
                modifier = Modifier.size(48.dp),
                color = MaterialTheme.colorScheme.primary
            )
        }
    }
    
    // Show error message if there's an error
    error?.let { errorMessage ->
        LaunchedEffect(errorMessage) {
            // Show error message for 3 seconds
            kotlinx.coroutines.delay(3000)
            error = null
        }
        
        Snackbar(
            modifier = Modifier.padding(16.dp),
            action = {
                TextButton(onClick = { error = null }) {
                    Text("Dismiss")
                }
            }
        ) {
            Text(errorMessage)
        }
    }
    
    Box(modifier = Modifier.fillMaxSize()) {
        if (isLoading) {
            CircularProgressIndicator(
                modifier = Modifier.align(Alignment.Center)
            )
        } else {
            // Debug button for testing Firestore
            if (error != null) {
                Column(
                    modifier = Modifier
                        .align(Alignment.Center)
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = error ?: "Unknown error",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.error,
                        textAlign = TextAlign.Center
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Button(
                        onClick = {
                            scope.launch {
                                try {
                                    // Check Firestore permissions
                                    firestoreService.checkFirestorePermissions().onSuccess {
                                        error = "Firestore permissions check successful. Trying to add test recipe..."
                                        
                                        // Add test recipe
                                        firestoreService.addTestRecipe().onSuccess {
                                            error = "Test recipe added successfully. Reloading recipes..."
                                            loadRecipes()
                                        }.onFailure { exception ->
                                            error = "Failed to add test recipe: ${exception.message}"
                                        }
                                    }.onFailure { exception ->
                                        error = "Firestore permissions check failed: ${exception.message}"
                                    }
                                } catch (e: Exception) {
                                    error = "Error: ${e.message}"
                                }
                            }
                        }
                    ) {
                        Text("Debug Firestore")
                    }
                }
            } else {
                when (selectedTab) {
                    DashboardTab.HOME -> {
                        Column(
                            modifier = Modifier
                                .fillMaxSize()
                                .padding(bottom = 80.dp)
                        ) {
                            // Top App Bar
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                horizontalArrangement = Arrangement.SpaceBetween,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = "Blush Bistro",
                                    style = MaterialTheme.typography.titleLarge.copy(
                                        fontWeight = FontWeight.Bold
                                    ),
                                    color = MaterialTheme.colorScheme.primary
                                )
                                
                                Row(
                                    horizontalArrangement = Arrangement.spacedBy(16.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    ThemeToggle()
                                    
                                    Box(
                                        modifier = Modifier
                                            .size(40.dp)
                                            .clip(CircleShape)
                                            .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f))
                                            .clickable { showProfileDialog = true },
                                        contentAlignment = Alignment.Center
                                    ) {
                                        Icon(
                                            imageVector = Icons.Filled.Person,
                                            contentDescription = "User Profile",
                                            tint = MaterialTheme.colorScheme.primary
                                        )
                                    }
                                    
                                    IconButton(onClick = onSignOut) {
                                        Icon(
                                            imageVector = Icons.AutoMirrored.Filled.Logout,
                                            contentDescription = "Sign Out",
                                            tint = MaterialTheme.colorScheme.primary
                                        )
                                    }
                                }
                            }
                            
                            // Search Bar
                            OutlinedTextField(
                                value = searchQuery,
                                onValueChange = { searchQuery = it },
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(horizontal = 16.dp, vertical = 8.dp),
                                placeholder = { Text("Search recipes...") },
                                leadingIcon = {
                                    Icon(
                                        imageVector = Icons.Default.Search,
                                        contentDescription = "Search"
                                    )
                                },
                                shape = RoundedCornerShape(16.dp),
                                singleLine = true
                            )

                            // Categories
                            LazyRow(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(vertical = 8.dp),
                                horizontalArrangement = Arrangement.spacedBy(8.dp),
                                contentPadding = PaddingValues(horizontal = 16.dp)
                            ) {
                                items(RecipeCategory.values()) { category ->
                                    FilterChip(
                                        selected = selectedCategories.contains(category),
                                        onClick = {
                                            selectedCategories = if (category == RecipeCategory.ALL) {
                                                setOf(RecipeCategory.ALL)
                                            } else {
                                                val newSet = selectedCategories.toMutableSet()
                                                if (newSet.contains(RecipeCategory.ALL)) {
                                                    newSet.remove(RecipeCategory.ALL)
                                                }
                                                if (newSet.contains(category)) {
                                                    newSet.remove(category)
                                                } else {
                                                    newSet.add(category)
                                                }
                                                if (newSet.isEmpty()) {
                                                    setOf(RecipeCategory.ALL)
                                                } else {
                                                    newSet
                                                }
                                            }
                                        },
                                        label = {
                                            Text(
                                                text = category.name,
                                                style = MaterialTheme.typography.bodyMedium
                                            )
                                        }
                                    )
                                }
                            }
                            
                            // Main content with scrolling
                            AnimatedVisibility(
                                visible = visible,
                                enter = fadeIn(animationSpec = tween(1000))
                            ) {
                                val filteredRecipes = when (selectedTab) {
                                    DashboardTab.HOME -> recipes.filter { recipe ->
                                        (selectedCategories.contains(RecipeCategory.ALL) || 
                                         selectedCategories.contains(recipe.category)) &&
                                        (searchQuery.isEmpty() || 
                                         recipe.name.contains(searchQuery, ignoreCase = true) ||
                                         recipe.description.contains(searchQuery, ignoreCase = true))
                                    }
                                    DashboardTab.FAVORITES -> recipes.filter { recipe ->
                                            userFavorites.contains(recipe.id) &&
                                        (selectedCategories.contains(RecipeCategory.ALL) || 
                                         selectedCategories.contains(recipe.category)) &&
                                        (searchQuery.isEmpty() || 
                                         recipe.name.contains(searchQuery, ignoreCase = true) ||
                                         recipe.description.contains(searchQuery, ignoreCase = true))
                                    }
                                    else -> emptyList()
                                }

                                // Log the number of recipes found
                                Log.d(DashboardScreenConstants.TAG, "Found ${filteredRecipes.size} recipes after filtering")

                                // Separate user recipes and predefined recipes
                                val userRecipes = filteredRecipes.filter { it.userId.isNotEmpty() && it.userId != "predefined" }
                                val predefinedRecipes = filteredRecipes.filter { it.userId.isEmpty() || it.userId == "predefined" }

                                Log.d(DashboardScreenConstants.TAG, "User recipes: ${userRecipes.size}, Predefined recipes: ${predefinedRecipes.size}")

                                val scrollState = rememberLazyListState()

                                Box(
                                    modifier = Modifier.fillMaxSize()
                                ) {
                                    LazyColumn(
                                        state = scrollState,
                                        modifier = Modifier
                                            .fillMaxSize()
                                            .padding(horizontal = 16.dp),
                                        verticalArrangement = Arrangement.spacedBy(16.dp)
                                    ) {
                                        // Show predefined recipes first
                                        if (predefinedRecipes.isNotEmpty()) {
                                            item {
                                                Text(
                                                    text = "Predefined Recipes",
                                                    style = MaterialTheme.typography.titleMedium,
                                                    fontWeight = FontWeight.Bold,
                                                    modifier = Modifier.padding(vertical = 8.dp)
                                                )
                                            }
                                            
                                            items(predefinedRecipes) { recipe ->
                                        RecipeCard(
                                            recipe = recipe,
                                                    isFavorite = userFavorites.contains(recipe.id),
                                            onFavoriteClick = { 
                                                        updateFavorites(recipe.id, !userFavorites.contains(recipe.id))
                                                    },
                                                    onClick = { showRecipeDetails = recipe }
                                                )
                                            }
                                        }
                                        
                                        // Show user recipes
                                        if (userRecipes.isNotEmpty()) {
                                            item {
                                                Text(
                                                    text = "My Recipes",
                                                    style = MaterialTheme.typography.titleMedium,
                                                    fontWeight = FontWeight.Bold,
                                                    modifier = Modifier.padding(vertical = 8.dp)
                                                )
                                            }
                                            
                                            items(userRecipes) { recipe ->
                                                RecipeCard(
                                                    recipe = recipe,
                                                    isFavorite = userFavorites.contains(recipe.id),
                                                    onFavoriteClick = { 
                                                        updateFavorites(recipe.id, !userFavorites.contains(recipe.id))
                                                    },
                                                    onClick = { showRecipeDetails = recipe }
                                                )
                                            }
                                        }
                                        
                                        // Show message if no recipes found
                                        if (filteredRecipes.isEmpty()) {
                                            item {
                                                Box(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(vertical = 32.dp),
                                                    contentAlignment = Alignment.Center
                                                ) {
                                                    Text(
                                                        text = "No recipes found",
                                                        style = MaterialTheme.typography.bodyLarge,
                                                        color = MaterialTheme.colorScheme.onSurfaceVariant
                                                    )
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    DashboardTab.FAVORITES -> {
                        Column(
                            modifier = Modifier
                                .fillMaxSize()
                                .padding(bottom = 80.dp)
                        ) {
                            // Search Bar
                            OutlinedTextField(
                                value = searchQuery,
                                onValueChange = { searchQuery = it },
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                placeholder = { Text("Search recipes...") },
                                leadingIcon = {
                                    Icon(
                                        imageVector = Icons.Default.Search,
                                        contentDescription = "Search"
                                    )
                                },
                                singleLine = true,
                                shape = MaterialTheme.shapes.large
                            )
                            
                            // Category Filter
                            LazyRow(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(horizontal = 16.dp),
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                items(RecipeCategory.values()) { category ->
                                    FilterChip(
                                        selected = selectedCategories.contains(category),
                                        onClick = {
                                            selectedCategories = if (selectedCategories.contains(category)) {
                                                if (selectedCategories.size > 1) {
                                                    selectedCategories - category
                                                } else {
                                                    selectedCategories
                                                }
                                            } else {
                                                selectedCategories + category
                                            }
                                        },
                                        label = { Text(category.name) },
                                        leadingIcon = if (selectedCategories.contains(category)) {
                                            {
                                                Icon(
                                                    imageVector = Icons.Default.Check,
                                                    contentDescription = null,
                                                    modifier = Modifier.size(FilterChipDefaults.IconSize)
                                                )
                                            }
                                        } else null
                                    )
                                }
                            }
                            
                            Spacer(modifier = Modifier.height(16.dp))
                            
                            Box(
                                modifier = Modifier.fillMaxSize()
                            ) {
                                val filteredRecipes = recipes.filter { recipe ->
                                    (searchQuery.isEmpty() || 
                                     recipe.name.contains(searchQuery, ignoreCase = true) || 
                                     recipe.description.contains(searchQuery, ignoreCase = true)) &&
                                    (selectedCategories.contains(RecipeCategory.ALL) || 
                                     selectedCategories.contains(recipe.category))
                                }
                                    
                                    // Separate user recipes and predefined recipes
                                    val userFavoriteRecipes = filteredRecipes.filter { 
                                        userFavorites.contains(it.id) && 
                                        it.userId.isNotEmpty() && 
                                        it.userId != "predefined" 
                                    }
                                    
                                    val predefinedFavoriteRecipes = filteredRecipes.filter { 
                                        userFavorites.contains(it.id) && 
                                        (it.userId.isEmpty() || it.userId == "predefined") 
                                    }
                                
                                val scrollState = rememberLazyListState()
                                
                                LazyColumn(
                                    state = scrollState,
                                    modifier = Modifier
                                        .fillMaxSize()
                                        .padding(horizontal = 16.dp),
                                    verticalArrangement = Arrangement.spacedBy(16.dp)
                                ) {
                                        // Show predefined favorite recipes first
                                        if (predefinedFavoriteRecipes.isNotEmpty()) {
                                            item {
                                                Text(
                                                    text = "Predefined Favorites",
                                                    style = MaterialTheme.typography.titleMedium,
                                                    fontWeight = FontWeight.Bold,
                                                    modifier = Modifier.padding(vertical = 8.dp)
                                                )
                                            }
                                            
                                            items(predefinedFavoriteRecipes) { recipe ->
                                        RecipeCard(
                                            recipe = recipe,
                                            isFavorite = true,
                                            onFavoriteClick = { 
                                                    updateFavorites(recipe.id, false)
                                            },
                                            onClick = { showRecipeDetails = recipe }
                                        )
                                    }
                                }
                                
                                    // Show user favorite recipes
                                    if (userFavoriteRecipes.isNotEmpty()) {
                                        item {
                                Text(
                                                text = "My Favorite Recipes",
                                                style = MaterialTheme.typography.titleMedium,
                                                fontWeight = FontWeight.Bold,
                                                modifier = Modifier.padding(vertical = 8.dp)
                                            )
                                        }
                                        
                                        items(userFavoriteRecipes) { recipe ->
                                            RecipeCard(
                                                recipe = recipe,
                                                isFavorite = true,
                                                onFavoriteClick = { 
                                                    updateFavorites(recipe.id, false)
                                                },
                                                onClick = { showRecipeDetails = recipe }
                                            )
                                        }
                                    }
                                    
                                    // Show message if no favorite recipes found
                                    if (userFavoriteRecipes.isEmpty() && predefinedFavoriteRecipes.isEmpty()) {
                                        item {
                                            Box(
                                    modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(vertical = 32.dp),
                                                contentAlignment = Alignment.Center
                                            ) {
                                                Text(
                                                    text = "No favorite recipes yet",
                                            style = MaterialTheme.typography.bodyLarge,
                                            color = MaterialTheme.colorScheme.onSurfaceVariant
                                        )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    DashboardTab.SETTINGS -> {
                        SettingsScreen()
                    }
                    DashboardTab.PROFILE -> {
                    UserProfileDialog(
                            onDismiss = { selectedTab = DashboardTab.HOME },
                        onSignOut = {
                                selectedTab = DashboardTab.HOME
                            onSignOut()
                        }
                        )
                    }
                }
                
                // Bottom Navigation
                NavigationBar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .fillMaxWidth(),
                    containerColor = MaterialTheme.colorScheme.surface
                ) {
                    NavigationBarItem(
                        icon = {
                            Icon(
                                imageVector = Icons.Default.Home,
                                contentDescription = "Home"
                            )
                        },
                        label = { Text("Home") },
                        selected = selectedTab == DashboardTab.HOME,
                        onClick = { selectedTab = DashboardTab.HOME }
                    )
                    NavigationBarItem(
                        icon = {
                            Icon(
                                imageVector = Icons.Default.Favorite,
                                contentDescription = "Favorites"
                            )
                        },
                        label = { Text("Favorites") },
                        selected = selectedTab == DashboardTab.FAVORITES,
                        onClick = { selectedTab = DashboardTab.FAVORITES }
                    )
                    NavigationBarItem(
                        icon = {
                            Icon(
                                imageVector = Icons.Default.Settings,
                                contentDescription = "Settings"
                            )
                        },
                        label = { Text("Settings") },
                        selected = selectedTab == DashboardTab.SETTINGS,
                        onClick = { selectedTab = DashboardTab.SETTINGS }
                    )
                }
                
                // Floating Action Button (only show on HOME and FAVORITES tabs)
                if (selectedTab == DashboardTab.HOME || selectedTab == DashboardTab.FAVORITES) {
                    FloatingActionButton(
                        onClick = { showAddRecipeDialog = true },
                        modifier = Modifier
                            .align(Alignment.BottomEnd)
                            .padding(16.dp)
                            .padding(bottom = 56.dp),
                        containerColor = MaterialTheme.colorScheme.primary
                    ) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = "Add Recipe",
                            tint = MaterialTheme.colorScheme.onPrimary
                        )
                    }
                }
                
                // Recipe Details Dialog
                if (showRecipeDetails != null && !showAddRecipeDialog) {
                    RecipeDetailsDialog(
                        recipe = showRecipeDetails!!,
                            onDismiss = { showRecipeDetails = null },
                            onEdit = { updatedRecipe ->
                                scope.launch {
                                    try {
                                        firestoreService.updateRecipe(updatedRecipe).onSuccess {
                                            loadRecipes() // Reload the recipes list
                                            showRecipeDetails = null
                                        }.onFailure { exception ->
                                            error = exception.message ?: "Failed to update recipe"
                                        }
                                    } catch (e: Exception) {
                                        error = e.message ?: "Failed to update recipe"
                                    }
                                }
                            },
                            onDelete = {
                                scope.launch {
                                    try {
                                        firestoreService.deleteRecipe(showRecipeDetails!!.id).onSuccess {
                                            loadRecipes() // Reload the recipes list
                                            showRecipeDetails = null
                                        }.onFailure { exception ->
                                            error = exception.message ?: "Failed to delete recipe"
                                        }
                                    } catch (e: Exception) {
                                        error = e.message ?: "Failed to delete recipe"
                                    }
                                }
                            },
                            isFavorite = userFavorites.contains(showRecipeDetails!!.id),
                            onFavoriteClick = {
                                updateFavorites(showRecipeDetails!!.id, !userFavorites.contains(showRecipeDetails!!.id))
                            }
                        )
                    }

                    // Add this inside the Scaffold content
                    if (showAddRecipeDialog) {
                        AddRecipeDialog(
                            onDismiss = { showAddRecipeDialog = false },
                            onRecipeAdded = { recipe ->
                                scope.launch {
                                    firestoreService.saveRecipe(recipe).onSuccess {
                                        loadRecipes()
                                    }.onFailure { exception ->
                                        error = exception.message ?: "Failed to save recipe"
                                    }
                                }
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun RecipeDetailsDialog(
    recipe: Recipe,
    onDismiss: () -> Unit,
    onEdit: (Recipe) -> Unit,
    onDelete: () -> Unit,
    isFavorite: Boolean = false,
    onFavoriteClick: () -> Unit = {}
) {
    var showEditDialog by remember { mutableStateOf(false) }
    var showDeleteConfirmation by remember { mutableStateOf(false) }
    
    MaterialTheme {
        AlertDialog(
            onDismissRequest = onDismiss,
            title = {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = recipe.name,
                        style = MaterialTheme.typography.headlineSmall
                    )
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // Favorite button
                        IconButton(onClick = onFavoriteClick) {
                            Icon(
                                imageVector = if (isFavorite) Icons.Default.Favorite else Icons.Default.FavoriteBorder,
                                contentDescription = if (isFavorite) "Remove from favorites" else "Add to favorites",
                                tint = if (isFavorite) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface
                            )
                        }
                        
                        IconButton(onClick = onDismiss) {
                            Icon(
                                imageVector = Icons.Default.Close,
                                contentDescription = "Close"
                            )
                        }
                    }
                }
            },
            text = {
                Column(
                        modifier = Modifier
                            .fillMaxWidth()
                        .verticalScroll(rememberScrollState())
                    ) {
                    Spacer(modifier = Modifier.height(16.dp))

                        Image(
                            painter = painterResource(id = recipe.imageResId),
                        contentDescription = "Recipe Image",
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(200.dp),
                            contentScale = ContentScale.Crop
                        )
                    
                    Spacer(modifier = Modifier.height(16.dp))

                    Text(
                        text = recipe.description,
                        style = MaterialTheme.typography.bodyLarge
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))

                        Text(
                        text = "Cook Time: ${recipe.cookTime} minutes",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                        Text(
                        text = "Category: ${recipe.category.name}",
                        style = MaterialTheme.typography.bodyMedium
                        )
                    
                    Spacer(modifier = Modifier.height(16.dp))

                    Text(
                        text = "Ingredients:",
                        style = MaterialTheme.typography.titleMedium
                    )
                    recipe.ingredients.forEach { ingredient ->
                        Text("â€¢ $ingredient")
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                        Text(
                        text = "Instructions:",
                        style = MaterialTheme.typography.titleMedium
                    )
                    recipe.cookingInstructions.forEachIndexed { index, instruction ->
                        Text("${index + 1}. $instruction")
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(
                            onClick = { showDeleteConfirmation = true }
                    ) {
                        Icon(
                                imageVector = Icons.Default.Delete,
                                contentDescription = "Delete"
                        )
                            Spacer(modifier = Modifier.width(4.dp))
                            Text("Delete")
                    }
                        Spacer(modifier = Modifier.width(8.dp))
                    Button(
                            onClick = { showEditDialog = true }
                        ) {
                            Icon(
                                imageVector = Icons.Default.Edit,
                                contentDescription = "Edit"
                            )
                            Spacer(modifier = Modifier.width(4.dp))
                            Text("Edit")
                        }
                    }
                }
            },
            confirmButton = { }
        )

        if (showEditDialog) {
            AddRecipeDialog(
                onDismiss = { showEditDialog = false },
                onRecipeAdded = { updatedRecipe ->
                    val recipeWithId = updatedRecipe.copy(id = recipe.id)
                    onEdit(recipeWithId)
                    showEditDialog = false
                }
            )
        }

        if (showDeleteConfirmation) {
    AlertDialog(
                onDismissRequest = { showDeleteConfirmation = false },
                title = { Text("Delete Recipe") },
                text = { Text("Are you sure you want to delete this recipe?") },
                confirmButton = {
                    TextButton(
                        onClick = {
                            onDelete()
                            showDeleteConfirmation = false
                        }
                    ) {
                        Text("Delete")
                    }
                },
                dismissButton = {
                    TextButton(onClick = { showDeleteConfirmation = false }) {
                        Text("Cancel")
                    }
                }
            )
        }
    }
}

@Composable
fun AddRecipeDialog(
    onDismiss: () -> Unit,
    onRecipeAdded: (Recipe) -> Unit
) {
    var name by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var cookTime by remember { mutableStateOf("") }
    var selectedCategory by remember { mutableStateOf(RecipeCategory.ALL) }
    var ingredients by remember { mutableStateOf("") }
    var instructions by remember { mutableStateOf("") }
    var expanded by remember { mutableStateOf(false) }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Add New Recipe") },
        text = {
            Column {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Recipe Name") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text("Description") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = cookTime,
                    onValueChange = { cookTime = it },
                    label = { Text("Cook Time") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(8.dp))
                
                // Category dropdown using stable API
                Box(modifier = Modifier.fillMaxWidth()) {
                    OutlinedTextField(
                        value = selectedCategory.name,
                        onValueChange = { },
                        readOnly = true,
                        label = { Text("Category") },
                        trailingIcon = {
                            IconButton(onClick = { expanded = !expanded }) {
                        Icon(
                                    imageVector = if (expanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                                    contentDescription = if (expanded) "Close dropdown" else "Open dropdown"
                        )
                    }
                        },
                        modifier = Modifier.fillMaxWidth()
                    )
                    
                    DropdownMenu(
                        expanded = expanded,
                        onDismissRequest = { expanded = false },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        RecipeCategory.values().forEach { category ->
                            DropdownMenuItem(
                                text = { Text(category.name) },
                                onClick = {
                                    selectedCategory = category
                                    expanded = false
                                }
                            )
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                        OutlinedTextField(
                    value = ingredients,
                    onValueChange = { ingredients = it },
                    label = { Text("Ingredients (one per line)") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(8.dp))
                            OutlinedTextField(
                    value = instructions,
                    onValueChange = { instructions = it },
                    label = { Text("Instructions (one per line)") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    val recipe = Recipe(
                        name = name,
                        description = description,
                            cookTime = cookTime,
                        imageResId = R.drawable.cake_image,
                            category = selectedCategory,
                            rating = 0f,
                            reviewCount = 0,
                        ingredients = ingredients.split("\n").filter { it.isNotBlank() },
                        cookingInstructions = instructions.split("\n").filter { it.isNotBlank() }
                        )
                    onRecipeAdded(recipe)
                }
            ) {
                Text("Save")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
} 